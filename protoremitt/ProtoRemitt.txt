pragma solidity ^0.4.12;

contract Remittance {
    bool public isRunning;
    bool public remittanceInProgress;
    address owner;
   
    uint deployPrice;
    uint public contractCommision;
    uint public claimAttempts;
    uint public remitIdCount;
    uint public deadline;
  
    //uint public coolOffDuration;
    //uint  public duration;
    
    struct RemitStruct { 
        address     depositor;
        address     exhanger;
        uint        amountDue;
        uint        amountClaimed;
        bytes32     passwordHash;
        bool        isActive;
    }
    
    mapping (uint => RemitStruct) public remitStructs;
    
    event LogSuccessfullyDeposited(uint remitId);
    event LogSuccessfullyClaimed(address claimant, uint amount);
    
    modifier adminOnlyAccess() {  
        require(msg.sender == owner);
        _;
    }
    
    modifier contractIsActive(){
        require(isRunning == true );
        _;
    }
    
    
    function Remittance() {
        isRunning = true;
        owner = msg.sender;
        //capture deploy gas price
       // contractCommision =  function of deployPrice - fixed offset amount
    }
    
    function deposit(address _receiver, address _exchanger, uint deposit,
                        bytes32 _depositorPassword, 
                        bytes32 _receiverPassword )
        public 
        payable
        contractIsActive
        returns (bool success)
    {
        if(_receiver != address(0) || _exchanger != address(0)) revert();
        //Trim passwords ?
        // if  (blockNumber + duration > current blocok number) throw;
        if ( msg.value + contractCommision < deposit) throw;
        
        // contractCommision =  function of deployPrice -set amount
       
       
        remitIdCount++;
        RemitStruct memory newRemit = RemitStruct(msg.sender,
                                                _exchanger,
                                                deposit,
                                                0, 
                                                keccak256(_depositorPassword, _receiverPassword),
                                                true);
        remitStructs[remitIdCount] = newRemit;
        
        
            
        // add deposit to 'Escrow' struct
        
        LogSuccessfullyDeposited(remitIdCount);
        remittanceInProgress = true;
        return true;
    }
    
    function isValidRemittance(uint _id)
        public 
        constant
        returns (bool status)
    {
        return remitStructs[_id].isActive;
    }
    
    function claim(uint _remitId, bytes32 _depositorPassword, bytes32 _receiverPasswordHash)
        public
        payable
        contractIsActive 
        returns (bool success)
    {
         //if remittance is invalid throw
         if(isValidRemittance(_remitId) == false) throw;
        //if not sender or exhanger throw
        if(remitStructs(_remitId).depositor  == msg.sender  |  remitStructs(_remitId).exhanger == msg.sender)) throw;
        
        //if sender tries to claim BEFORE deadline, log event, return false
        
        //if exhanger tries to claim after deadline, log event, return false
        
        
        
        //verify passwords
        if (keccak256(_depositorPasswordHash, _receiverPasswordHash) != passwordHash) 
        {
            throw;
        }
        
        //Empty 'Escrow' struct and fill exchangeer's struct
        
        //prevent re-entrancy and allocate amounts
        
       LogSuccessfullyClaimed(msg.sender, amount);
        remittanceInProgress = false;
        return true;
    }
    
    
    
    function switchRunning(bool onOff)
        adminOnlyAccess
        public 
    {
       if(!remittanceInProgress){
         isRunning =  onOff; 
       }
    }
    
    function Kill()
        adminOnlyAccess
        public
    {
        suicide(owner);
    }
    
    function () {}
}
