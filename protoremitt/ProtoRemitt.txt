pragma solidity ^0.4.10;

contract Remittance {
    address owner;
    bool public isRunning;
    uint public remittanceInProgress;
    uint deployPrice;
    uint public contractCommision;
    uint public claimAttempts;
    uint public remitIdCount;
    uint public duration;
  
    //uint public coolOffDuration;
    //uint  public duration;
    
    struct RemitStruct { 
        address     depositor;
        address     exhanger;
        uint        amountDue;
        uint        amountClaimed;
        bytes32     passwordHash;
        uint        deadline;
        bool        isActive;
    }
    
    mapping (uint => RemitStruct) public remitStructs;
    
    event LogSuccessfullyDeposited(uint remitId);
    event LogSuccessfullyClaimed(address claimant, uint amount);
    
    modifier adminOnlyAccess() {  
        require(msg.sender == owner);
        _;
    }
    
    modifier contractIsActive(){
        require(isRunning == true );
        _;
    }
    
    
    function Remittance() {
        isRunning = true;
        owner = msg.sender;
        //capture deploy gas price
       // contractCommision =  function of deployPrice - fixed offset amount
    }
    
    function deposit(address _exchanger, bytes32 _depositorPassword, 
                        bytes32 _receiverPassword )
        public 
        payable
        contractIsActive
        returns (bool success)
    {
        if( _exchanger != address(0)) revert();
        //Trim passwords ?
        // if  (blockNumber + duration > current block number) throw;
        if (msg.value < contractCommision) throw;
        // contractCommision =  function of deployPrice -set amount
       
       
        remitIdCount++;
        RemitStruct memory newRemit = RemitStruct(msg.sender,
                                                _exchanger,
                                                (msg.value - contractCommision),
                                                0, 
                                                keccak256(_depositorPassword, _receiverPassword),
                                                block.number + duration,
                                                true);
        remitStructs[remitIdCount] = newRemit;
        
        
            
        // add deposit to 'Escrow' struct
        
        LogSuccessfullyDeposited(remitIdCount);
        remittanceInProgress++;
        return true;
    }
    
    function isValidRemittance(uint _id)
        public 
        constant
        returns (bool status)
    {
        return remitStructs[_id].isActive;
    }
    
    function getPasswordHash(uint _id)
        public 
        constant
        returns (bytes32 hash)
    {
         return remitStructs[_id].passwordHash;
    }
    
     function getAmountDue(uint _id)
        public 
        constant
        returns (uint due)
    {
         return  remitStructs[_id].amountDue;
    }
    
    function retireRemit(uint _id)
        public
        contractIsActive
    {
        remitStructs[_id].isActive = false;
    }
        
    
    
    function claim(uint _remitId, bytes32 _depositorPassword, bytes32 _receiverPassword)
        public
        payable
        contractIsActive 
        returns (bool success)
    {
         //if remittance is invalid throw
         if(isValidRemittance(_remitId) == false) throw;
        //if not sender or exhanger throw
        //if( msg.sender == remitStructs(_remitId).depositor       |  remitStructs(_remitId).exhanger == msg.sender) throw;
        
        //if sender tries to claim BEFORE deadline, log event, return false
        //if(remitStructs(_remitId).depositor  == msg.sender   |  remitStructs(_remitId).deadline > block.Number) throw;
        
        //if exhanger tries to claim after deadline, log event, return false
        
        
        
        //verify passwords
        if (keccak256(_depositorPassword, _receiverPassword) != getPasswordHash(_remitId)) throw;
        
        
        //Empty 'Escrow' struct and fill exchangeer's struct
        
        //prevent re-entrancy and allocate amounts
        
       LogSuccessfullyClaimed(msg.sender, getAmountDue(_remitId));
       retireRemit(_remitId);
        if(remittanceInProgress > 0) {remittanceInProgress--;}
        return true;
    }
    
    
    
    function switchRunning(bool onOff)
        adminOnlyAccess
        public 
    {
       if(remittanceInProgress == 0){
         isRunning =  onOff; 
       }
    }
    
    function Kill()
        adminOnlyAccess
        public
    {
        suicide(owner);
    }
    
    function () {}
}
